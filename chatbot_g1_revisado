from flask import Flask, render_template, request, jsonify
import os
import pandas as pd
import json
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.naive_bayes import MultinomialNB
from googleapiclient.discovery import build

app = Flask(__name__)

# ============================================================
#  CONFIGURAÇÃO DE CHAVES (via VARIÁVEL DE AMBIENTE)
#  NÃO deixar chave escrita no código!
# ============================================================
GOOGLE_API_KEY = os.environ.get("GOOGLE_API_KEY")
GOOGLE_CSE_CX = os.environ.get("GOOGLE_CSE_CX")

# Links fixos oficiais – sempre aparecem na resposta
LINKS_FIXOS = {
    "receita": "https://www.gov.br/receitafederal/pt-br",
    "mei": "https://www.gov.br/empresas-e-negocios/pt-br/empreendedor",
    "sebrae": "https://sebrae.com.br/sites/PortalSebrae/"
}

# Variáveis globais do modelo
vetorizador = None
modelo = None
respostas_db = {}

# ============================================================
#  CARREGAMENTO DA BASE LOCAL (perguntas.csv + respostas.json)
# ============================================================
try:
    dados = pd.read_csv("perguntas.csv")

    frases = dados["frase"].astype(str).tolist()
    categorias = dados["categoria"].astype(str).tolist()

    vetorizador = CountVectorizer()
    X = vetorizador.fit_transform(frases)

    modelo = MultinomialNB()
    modelo.fit(X, categorias)
    print("Modelo treinado com sucesso!")

    with open("respostas.json", "r", encoding="utf-8") as f:
        respostas_db = json.load(f)
    print("Respostas carregadas!")

except Exception as e:
    print(f"[ERRO] Ao carregar arquivos ou treinar modelo: {e}")
    print("A API vai tentar funcionar com recursos limitados (sem base local).")


# ============================================================
#  BUSCA NO GOOGLE (fallback, usando Custom Search)
# ============================================================
def buscar_no_google(termo: str):
    """
    Busca links no Google Custom Search.
    Só funciona se GOOGLE_API_KEY e GOOGLE_CSE_CX estiverem configurados.
    """
    if not GOOGLE_API_KEY or not GOOGLE_CSE_CX:
        # Sem chave configurada, não tenta chamar API externa
        return []

    try:
        service = build("customsearch", "v1", developerKey=GOOGLE_API_KEY)
        res = service.cse().list(q=termo, cx=GOOGLE_CSE_CX, num=3).execute()

        resultados = []
        if "items" in res:
            for item in res["items"]:
                resultados.append({
                    "titulo": item.get("title", ""),
                    "link": item.get("link", "")
                })
        return resultados

    except Exception as e:
        print(f"[ERRO] Na chamada da API do Google: {e}")
        return []


# ============================================================
#  LÓGICA CENTRAL DO CHATBOT
#  1) Tenta responder pela base local
#  2) Se não conseguir, tenta Google (Receita + Sebrae/MEI)
#  3) Sempre acrescenta LINKS_FIXOS no retorno
# ============================================================
def gerar_resposta(mensagem_usuario: str):
    mensagem_usuario = (mensagem_usuario or "").strip()

    if not mensagem_usuario:
        return {
            "resposta": "Por favor, digite uma dúvida para que eu possa ajudar.",
            "origem": None,
            "links_locais": [],
            "links_google": [],
            "links_fixos": LINKS_FIXOS,
            "categoria_detectada": None
        }

    resposta_final = ""
    links_uteis = []
    links_google = []
    categoria_prevista = None
    origem = None  # "local" ou "google"

    # 1) Tenta usar a base local (modelo + JSON)
    if modelo is not None and vetorizador is not None and respostas_db:
        try:
            vetor_pergunta = vetorizador.transform([mensagem_usuario])
            categoria_prevista = modelo.predict(vetor_pergunta)[0]

            resp_data = respostas_db.get(categoria_prevista)
            if resp_data:
                resposta_final = resp_data.get("texto", "")
                links_uteis = resp_data.get("links", []) or []
                origem = "local"

        except Exception as e:
            print(f"[ERRO] Na predição ou leitura do JSON: {e}")

    # 2) Se não encontrou resposta LOCAL, tenta buscar no Google
    if not resposta_final:
        origem = "google"
        resposta_final = (
            "Não encontrei uma resposta específica na minha base local. "
            "Vou tentar sugerir alguns links oficiais que podem ajudar."
        )

        termo_busca = f"Receita Federal Sebrae MEI {mensagem_usuario}"
        links_google = buscar_no_google(termo_busca)

        # Se nem o Google trouxe algo útil, ajusta mensagem
        if not links_google:
            resposta_final = (
                "No momento não consegui localizar uma resposta específica. "
                "Recomendo acessar diretamente os portais oficiais abaixo."
            )

    # 3) Monta payload final
    return {
        "resposta": resposta_final,
        "origem": origem,
        "links_locais": links_uteis,       # da base local (respostas.json)
        "links_google": links_google,      # apenas se precisou usar o Google
        "links_fixos": LINKS_FIXOS,        # sempre presentes
        "categoria_detectada": categoria_prevista
    }


# ============================================================
#  ROTAS DA APLICAÇÃO
# ============================================================

@app.route("/")
def index():
    """Frontend (index.html) feito pelos alunos."""
    return render_template("index.html")


@app.route("/get_response", methods=["POST"])
def get_response():
    """
    Rota usada pelo frontend atual.
    Espera um campo 'msg' no form-data.
    """
    mensagem_usuario = request.form.get("msg", "")
    payload = gerar_resposta(mensagem_usuario)
    return jsonify(payload)


@app.route("/chat", methods=["POST"])
def chat_json():
    """
    Rota de API em JSON para o TI/portal da faculdade.

    Exemplo de requisição:
        POST /chat
        {
            "pergunta": "Como faço para declarar o MEI?"
        }
    """
    data = request.get_json(silent=True) or {}
    mensagem_usuario = data.get("pergunta", "")
    payload = gerar_resposta(mensagem_usuario)
    return jsonify(payload)


# ============================================================
#  EXECUÇÃO
# ============================================================
if __name__ == "__main__":
    # Em produção, ideal usar gunicorn/uwsgi.
    # Aqui deixo pronto para rodar local e em servidor simples.
    app.run(host="0.0.0.0", port=5000, debug=False)
